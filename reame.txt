Задача .
/* 
https://jsfiddle.net/7a2ngzm0/ в примере по ссылке я написал на скорую руку игру крестики-нолики. 
Я постарался над алгоритмом проверки победы и смог сделать игру универсальной для любого размера поля. 
3х3, 5х5, 100х100 - размер поля можно указать любой и код будет с ним работать одинаково.
размер можно задать константой SIZE, а размер ячеек через CELL_SIZE.
но, конкретно этот код можно улучшать и улучшать. Я предлагаю сосредоточиться на нескольких моментах.
1) есть баг, что если кликнуть на уже заполненную ячейку, то это содержимое перезапишется, то есть можно кликать 
на ячейки противника или много раз на свою и это будет считаться ходом. Устранить этот баг, чтобы, если по ячейке был клик,
 то повторный клик ни к чему бы не приводил)
2) в игре есть, как я его называю "искусственный идиот" - код, отвечающий за ходы компьютера против игрока. 
Он сейчас делает ходы просто случайным образом на пустые ячейки из-за чего почти всегда проигрывает. Код логики в функции checkFree().
Превратите его в подобие "искусственного интеллекта". Например, чтобы он первым своим ходом ставил нолик на центральную ячейку.
Плюс можно анализировать "вес" столбцов, строк, диагоналей. Например, если игрок ставит где-то крестик, 
то строка, столбец, диагональ с этим крестиком увеличивают свой вес и компьютер сортирует все поля по весу и случайно ходит туда, 
где вес больше, а не куда-попало.
3) мне кажется, что функции делают слишком много операций. Разбейте их на несколько, сделайте код чище
4) если удастся, то найдите более оптимальный или простой алгоритм проверки победы, который у меня в checkField()
5) наверняка там закралось ещё не мало багов, исправьте, если найдёте
6) сделайте возможность, чтобы иногда первым ходил компьютер или просто это было случайно (50% первый игрок, 50% компьютер)
*/




Часть багов исправлена.

2) Для "более простого алгоритма победы" сделан массив весов для каждой линии, одномерный: 
ряды, обратная диагональ, столбцы, главная диагональ. 

И при каждом ходе в ссответсвущий єлемент  добавляется +1 для игрока, или вычитается -1 для АИ.
Веса диагоналей слегка увеличены, причем рандомно-неодинаково чтоб разница веса диагоналей менялась от игры к игре.

Таким образом победа определяется просто как  "вес одной из диагоналей больше или меньше размера SIZE" 

3)добавление "интеллекта" CPU немного увеличило код. Создается в начале массив свободных клеток. по сути двумерный. 
каждый элемент "первого измерения"  это массив содержащий свободные клетки "линии".
При каждом ходе игрока или АИ из соответсвующих массивов(ряда, столбца и если надо диагонали) удаляются занятые клетки.
Все это нужно для того чтобы когда АИ определяет линию в которую будет делать ход, отсеивать уже занятые линии.

алгоритм хода АИ.
    - если все ячейки заняты - ничья.
    - если свободна среедина - в нее.
    - сортируется массив весов.  определяется самая опасная линия и самая перспективная(для победы) 
    при этом сортированный массив перебирается до тех пор, пока  в выбираемых линиях не будут свободные ячейки
    ( т.е. массив свободных клеток соотвествующей линии не пуст.)  либо пока не переберется всё.

